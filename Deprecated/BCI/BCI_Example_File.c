#pragma config(Sensor, dgtl1,  leftQuad,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightQuad,      sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  liftQuad,       sensorQuadEncoder)
#pragma config(Motor,  port1,           randomMotor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port2,           rightFront,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           leftFront,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           leftBack,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rightBack,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           rightTopLift,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           leftTopLift,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           leftBottomLift,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           rightBottomLift,     tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

//Drivetrain
#define DRIVE_X

//Lift
#define LIFT_4_1
#define LIFT_SPEED 127
#define LIFT_UP Btn8U
#define LIFT_DOWN Btn8D

#include "Bulldog_Competition_Includes.c"

//Variable to wait in pre_auton while the user has not yet pressed the button
//to start driver control
bEndPreAuton = false;

void pre_auton()
{
	bStopTasksBetweenModes = true;
	bLCDBacklight = true;
	
	//Must call this before anything else with the drivetrain
	initializeDrivetrain(leftFront, leftBack, rightFront, rightBack, leftQuad, right Quad, 0.5, 0.5, 0.5);
	
	//Must call this before anything else with the lift
	initializeLift(leftTopLift, leftBottomLift, rightTopLift, rightBottomLift, liftQuad, 0.5, 0.5, 0.5);
	
	//We want slew rate control over this motor, so addMotor has to be used
	addMotor(randomMotor);
	
	//Level 1
	menu *optionsMenu = newMenu("Options");
	menu *startDriverControlMenu = newMenu("Start DC", 1)
	pairMenus(optionsMenu, startDriverControlMenu);
	
	//Level 2
	menu *driveForwardMenu = newMenu("Drive Forward", 2);
	menu *turnRightMenu = newMenu("Turn Right", 3);
	menu *strafeLeftMenu = newMenu("Strafe Left", 4);
	menu *controlRandomMotorMenu = newMenu("Drive random motor", 5);
	pairMenus(driveForwardMenu, turnRightMenu, strafeLeftMenu, controlRandomMotorMenu);
	
	//Link level 2 to the options menu
	makeLevel(driveForwardMenu, turnRightMenu, strafeLeftMenu, controlRandomMotorMenu, optionsMenu);
	
	//Run
	startLCDControl();
	
	while(!bEndPreAuton) { wait1Msec(25); }
}

void invoke(int func)
{
	switch (func)
	{
		//Start driver control
		case 1:
			stopLCDControl();
			bEndPreAuton = true;
			break;
		
		//Drive forward 360 ticks
		case 2:
			drive(360);
			break;
		
		//Turn right 90 ticks
		case 3:
			turnPID(90);
			break;
		
		//Strafe left 180 ticks
		case 4:
			strafe(-180);
			break;
		
		//Set the power of randomMotor to 127
		case 5:
			_SetMotorSpeed(randomMotor, 127);
			break;
		
		default:
			break;
	}
}

task autonomous()
{
	drive(360);
}

task usercontrol()
{
	startDrivetrainControl();
	startLiftControl();
}