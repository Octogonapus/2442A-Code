#pragma config(Sensor, in1,    powerExpander,  sensorAnalog)
#pragma config(Sensor, in2,    gyro,           sensorGyro)
#pragma config(Sensor, in3,    accelX,         sensorAccelerometer)
#pragma config(Sensor, in4,    accelY,         sensorAccelerometer)
#pragma config(Sensor, in5,    leftLineSensor, sensorLineFollower)
#pragma config(Sensor, in6,    rightLineSensor, sensorLineFollower)
#pragma config(Sensor, dgtl1,  rightLauncherQuad, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  brake,          sensorDigitalOut)
#pragma config(Sensor, dgtl4,  leftLauncherQuad, sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  leftDriveQuad,  sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  rightDriveQuad, sensorQuadEncoder)
#pragma config(Sensor, dgtl11, intakeLimit,    sensorTouch)
#pragma config(Motor,  port1,           intake,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           leftLauncherBottom, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           leftLauncherTop, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           rightLauncherBottom, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           rightLauncherTop, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rightDriveFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightDriveBack, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           leftDriveBack, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           leftDriveFront, tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

#pragma DebuggerWindows("Motors")
#pragma DebuggerWindows("Sensors")

#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

#include "Vex_Competition_Includes.c"

#define LCD_SAFETY_REQ_COMP_SWITCH
#define USING_QUADS
#define USING_GYRO
#define PID_NUM 1

#include "BCI_V3\Bulldog_Core_Includes.h"
#include "autonFunctions.c"

int leftSpeed = 127;
int rightSpeed = 127;

void pre_auton()
{
	bStopTasksBetweenModes = true;

	initializeSensors();

	//Hand motors to slew rate controller
	addMotor(intake);
	addMotor(leftDriveFront);
	addMotor(rightDriveFront);
	addMotor(leftLauncherTop, 0.7);
	addMotor(rightLauncherTop, 0.7);
	addMotor(rightLauncherBottom, 0.7);
	addMotor(leftLauncherBottom, 0.7);
	addMotor(rightDriveBack);
	addMotor(leftDriveBack);
}

task autonomous()
{

}

task usercontrol()
{
	//Drivetrain variables
	int leftV, rightV;
	bool slowMode = false;
	const float slowModePercentage = 0.6;

	//Launcher variables
	bool launcherOn = false;
	int launcherTargetRPM = 0;

	bool runLauncher = false, runIntake = false;

	const float kP = 0.25;

	startTask(motorSlewRateTask);
	startTask(printBatteryVoltage);
	startTask(monitorRPM);

	string mainBatteryLevel, powerExpanderLevel, fullBattString, rpmDiffString, rpmString, speedString;

	while (true)
	{
		/* ------------ DRIVETRAIN ------------ */

		//Grab values from joystick
		leftV = vexRT[JOY_JOY_LV];
		rightV = vexRT[JOY_JOY_RV];

		//Bound joystick values
		leftV = abs(leftV) < JOY_THRESHOLD ? 0 : leftV;
		rightV = abs(rightV) < JOY_THRESHOLD ? 0 : rightV;

		//Invert slow mode flag
		if (vexRT[JOY_BTN_RR])
		{
			slowMode = !slowMode;
			waitForZero(vexRT[JOY_BTN_RR]);
		}

		//Send powers to motors
		if (!slowMode)
		{
			//setLeftDriveMotors(leftV);
			setLeftDriveMotorsRaw(leftV);
			//setRightDriveMotors(rightV);
			setRightDriveMotorsRaw(rightV);
		}
		else
		{
			//Scale motor power by a slow mode specific constant
			setLeftDriveMotors((int)(leftV * slowModePercentage));
			setRightDriveMotors((int)(rightV * slowModePercentage));
		}

		/* -------------- INTAKE -------------- */

		if (vexRT[JOY_TRIG_LD])
		{
			//If a ball is waiting to launch
			if (SensorValue[intakeLimit])
			{
				//If the launcher is at the correct speed
				if (leftRPM >= launcherTargetRPM || rightRPM >= launcherTargetRPM)
				{
					setIntakeMotors(127);
				}
				else
				{
					setIntakeMotors(0);
				}
			}
			//Ball is not waiting to launch
			else
			{
				setIntakeMotors(127);
			}
		}
		else if (vexRT[JOY_TRIG_LU])
		{
			setIntakeMotors(-127);
		}
		else
		{
			setIntakeMotors(0);
		}

		/* ------------- LAUNCHER ------------- */

		if (vexRT[JOY_TRIG_RD])
		{
			launcherOn = !launcherOn;
			waitForZero(vexRT[JOY_TRIG_RD]);
		}

		//If the launcher should run
		if (launcherOn)
		{
			//setLeftLauncherMotors(_GetPIDSpeed(launcherLeftPID));
			setLeftLauncherMotors(127);
			setRightLauncherMotors(127);
		}
		else
		{
			setLeftLauncherMotors(0);
			setRightLauncherMotors(0);
		}

		//Launcher speed targets
		if (vexRT[JOY_BTN_RL])
		{
			//Full field shot
			launcherTargetRPM = 400;
		}
		else if (vexRT[JOY_BTN_RR])
		{
			//Half field shot
			launcherTargetRPM = 200;
		}
		else if (vexRT[JOY_BTN_RU])
		{
			launcherTargetRPM += 20;
		}
		else if (vexRT[JOY_BTN_RD])
		{
			launcherTargetRPM -= 20;
		}

		/* ------------- SHIFTER ------------- */

		if (vexRT[JOY_BTN_LR])
		{
			//SensorValue[shifter] = 1;
			waitForZero(vexRT[JOY_BTN_LR]);
		}

		/* ------------- PARKING BRAKE ------------- */

		if (vexRT[JOY_BTN_LL])
		{
			SensorValue[brake] = 1;
			waitForZero(vexRT[JOY_BTN_LL]);
		}

		//sprintf(mainBatteryLevel, "Main: %1.2f%c", nImmediateBatteryLevel / 1000.0, 'V');
		sprintf(powerExpanderLevel, "Expander: %1.2f%c", SensorValue[powerExpander] / 275.0, 'V');
		sprintf(fullBattString, "%1.2f, %1.2f", nImmediateBatteryLevel / 1000.0, SensorValue[powerExpander] / 275.0);
		sprintf(rpmDiffString, "L:R Diff: %1.2f", rpmDiff);
		sprintf(rpmString, "%1.2f, %1.2f", leftRPM, rightRPM);
		sprintf(speedString, "%d, %d", leftSpeed, rightSpeed);

		//displayLCDCenteredString(0, mainBatteryLevel);
		displayLCDCenteredString(0, rpmDiffString);
		displayLCDCenteredString(1, rpmString);
		//displayLCDCenteredString(1, powerExpanderLevel);
		//displayLCDCenteredString(1, fullBattString);
		//displayLCDCenteredString(1, speedString);

		wait1Msec(25);
	}
}
