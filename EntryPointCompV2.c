#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    powerExpander,  sensorAnalog)
#pragma config(Sensor, in2,    gyro,           sensorGyro)
#pragma config(Sensor, in3,    accelX,         sensorAccelerometer)
#pragma config(Sensor, in4,    accelY,         sensorAccelerometer)
#pragma config(Sensor, in5,    leftLineSensor, sensorLineFollower)
#pragma config(Sensor, in6,    rightLineSensor, sensorLineFollower)
#pragma config(Sensor, dgtl1,  intakeLED,      sensorLEDtoVCC)
#pragma config(Sensor, dgtl3,  brake,          sensorDigitalOut)
#pragma config(Sensor, dgtl4,  shifter,        sensorDigitalOut)
#pragma config(Sensor, dgtl5,  rightDriveQuad, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  leftDriveQuad,  sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  intakeLimit,    sensorTouch)
#pragma config(Sensor, I2C_1,  leftBankIME,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  rightBankIME,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           intakeFront,   tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           leftDriveBottomFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           leftDriveBottomBack, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port4,           leftDrivePerma, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           leftDriveTopBack, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rightDriveBottomFront, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           rightDriveBottomBack, tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port8,           rightDrivePerma, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           rightDriveTopBack, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          intakeBack,    tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

#pragma DebuggerWindows("Motors")
#pragma DebuggerWindows("Sensors")

#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

#include "Vex_Competition_Includes.c"

//Setup LCD
#define LCD_SAFETY_REQ_COMP_SWITCH
#define MENU_NUM 6
#define USING_QUADS
#define USING_GYRO

//Auton function prototypes
void startAutonomous();

//Whether or not to end pre auton
bool endPreAuton = false;

//The autonomous program to run
int autonSelection = -1;

#include "Bulldog_Core_Includes.h"

//Launcher velocity controller
vel_TBH launcherTBH;

//Autonomous program file includes
#include "autonIncludes.h"

//Programming skills routine
#include "programmingSkills.c"

//Menus
//Level 1 - General Info
menu *programmingSkillsMenu;
menu *autonomousSelectionMenu;
menu *endPreAutonMenu;
menu *batteryVoltageMenu;
menu *powerExpanderVoltageMenu;
menu *backupBatteryVoltageMenu;

void pre_auton()
{
	bStopTasksBetweenModes = true;

	//Initialize launcher TBH controller
	vel_TBH_InitController(&launcherTBH, leftDriveBottomBack, 0.25, 75);

	//Iniialize all sensors
	initializeSensors();

	//Hand motors to slew rate controller
	addMotor(intakeFront, MOTOR_FAST_SLEW_RATE);
	addMotor(leftDriveBottomFront, MOTOR_FAST_SLEW_RATE);
	addMotor(leftDriveBottomBack, MOTOR_FAST_SLEW_RATE);
	addMotor(leftDrivePerma, MOTOR_FAST_SLEW_RATE);
	addMotor(leftDriveTopBack, MOTOR_FAST_SLEW_RATE);
	addMotor(rightDriveBottomFront, MOTOR_FAST_SLEW_RATE);
	addMotor(rightDriveBottomBack, MOTOR_FAST_SLEW_RATE);
	addMotor(rightDrivePerma, MOTOR_FAST_SLEW_RATE);
	addMotor(rightDriveTopBack, MOTOR_FAST_SLEW_RATE);
	addMotor(intakeBack, MOTOR_FAST_SLEW_RATE);

	//Menu system
	//Level 1 - General Info
	autonomousSelectionMenu = newMenu("Select Auton", 2);
	programmingSkillsMenu = newMenu("Prog Skills", 3);
	endPreAutonMenu = newMenu("Confirm", 1);

	string batteryVoltage;
	sprintf(batteryVoltage, "Main: %1.2f%c", nAvgBatteryLevel / 1000.0, 'V');
	batteryVoltageMenu = newMenu(batteryVoltage);

	string powerExpanderVoltage;
	sprintf(powerExpanderVoltage, "Expander: %1.2f%c", SensorValue[powerExpander] / ANALOG_IN_TO_V, 'V');
	powerExpanderVoltageMenu = newMenu(powerExpanderVoltage);

	string backupBatteryVoltage;
	sprintf(backupBatteryVoltage, "Backup: %1.2f%c", BackupBatteryLevel / 1000.0, 'V');
	backupBatteryVoltageMenu = newMenu(backupBatteryVoltage);

	linkMenus(programmingSkillsMenu, autonomousSelectionMenu, endPreAutonMenu, batteryVoltageMenu, powerExpanderVoltageMenu, backupBatteryVoltageMenu);

	bLCDBacklight = true;
	startTask(updateLCDTask);
	while (!getLCDSafetyState() && !endPreAuton) { wait1Msec(50); }

}

task autonomous()
{
	//autonSelection = 111;
	startAutonomous();
}

task usercontrol()
{
	//startTask(autonomous);
	//wait1Msec(15000);
	//stopTask(autonomous);

	//Reinitialize velocity controller after autonomous
	vel_TBH_ReInitController(&launcherTBH);

	//Drivetrain variables
	int leftV = 0, rightV = 0;
	const int drivetrainSlewRate = 50;

	//Intake variables
	const int intakeMinimumError = 3;
	bool intake_prevStateIn = false;

	//Launcher variables
	const int boostTime = (-375 * (nAvgBatteryLevel / 1000.0)) + 3500;
	const int launcher_FullCourt = 90, launcher_FullCourt_Approx = 79, launcher_MidCourt = 80, launcher_MidCourt_Approx = 63;
	bool launcherOn = false, launcherBypass = false, revLauncher = false, limitSwitchLast = false, launcherJustBoosted = false, launcher_UseBypass = false;
	bool launcher127Time = false;
	int launcherTargetRPM = 90, launcherTargetRPM_last = 0;
	int launcherPOWER = 52, launcherCurrentPower = 0, launcherRPMIncrement = 1;

	startTask(motorSlewRateTask);

	bLCDBacklight = true;

	string line1String, line2String;

	timer launcherTimer, intakeTimer, lcdTimer, t;
	timer_Initialize(&launcherTimer);
	timer_Initialize(&intakeTimer);
	timer_Initialize(&lcdTimer);

	//timer_Initialize(&t);
	//while (timer_GetDTFromStart(t) <= 8000)
	writeDebugStreamLine("Battery Voltage: %1.2f\n", nAvgBatteryLevel / 1000.0);
	writeDebugStreamLine("Target Velocity, Filtered Velocity, Unfiltered Velocity, Motor Power, Error");
	while (true)
	{
		//Update LCD every 100 ms
		if (timer_Repeat(&lcdTimer, 100))
		{

			sprintf(line1String, "E:%d, TV:%d", vel_TBH_GetError(&launcherTBH), vel_TBH_GetTargetVelocity(&launcherTBH));
			//sprintf(line1String, "L: %d, R: %d", getMotorVelocity(leftDriveBottomBack), getMotorVelocity(rightDriveBottomBack));
			//sprintf(line1String, "Err:%d, B:%d", vel_TBH_GetError(&launcherTBH), abs(vel_TBH_GetError(&launcherTBH)) < intakeMinimumError);
			displayLCDCenteredString(0, line1String);

			//sprintf(line2String, "%1.2f", SensorValue[powerExpander] / ANALOG_IN_TO_MV);
			//sprintf(line2String, "CP:%d", launcherCurrentPower);
			//sprintf(line2String, "LH: %d, RH: %d", getMotorVelocity(leftDriveBottomBack) * 25, getMotorVelocity(rightDriveBottomBack) * 25);
			sprintf(line2String, "Cur Pow:%d", launcherCurrentPower);
			displayLCDCenteredString(1, line2String);
		}

		//writeDebugStreamLine("%d,%d,%d,%d,%d", vel_TBH_GetTargetVelocity(&launcherTBH), vel_TBH_GetVelocity(&launcherTBH), getMotorVelocity(leftDriveBottomBack),
		//			launcherCurrentPower,
		//			vel_TBH_GetError(&launcherTBH));

		/* ------------ DRIVETRAIN ------------ */

		//If the launcher is not on
		if (!launcherOn)
		{
			//Shift into drive gear
			shiftGear(0);

			//Change drive motors' slew rate back to normal after launcher control
			setAllDriveMotorsSlewRate(drivetrainSlewRate);

			//Grab values from joystick
			leftV = vexRT[JOY_JOY_LV];
			rightV = vexRT[JOY_JOY_RV];

			//Bound joystick values
			leftV = abs(leftV) < JOY_THRESHOLD ? 0 : leftV;
			rightV = abs(rightV) < JOY_THRESHOLD ? 0 : rightV;

			//Send these values to the drivetrain
			setAllLeftDriveMotors(leftV);
			setAllRightDriveMotors(rightV);
		}
		//If the launcher is on
		else
		{
			//Change drive motors' slew rate back to normal after launcher control
			setAllPermaDriveMotorsSlewRate(drivetrainSlewRate);

			//Grab values from joystick
			leftV = vexRT[JOY_JOY_LV];
			rightV = vexRT[JOY_JOY_RV];

			//Bound joystick values
			leftV = abs(leftV) < JOY_THRESHOLD ? 0 : leftV;
			rightV = abs(rightV) < JOY_THRESHOLD ? 0 : rightV;

			//Send these values to the drivetrain
			setPermaLeftDriveMotors(leftV);
			setPermaRightDriveMotors(rightV);
		}

		if (vexRT[JOY_TRIG_RU])
		{
			driveQuad(-127, 750);

			launcherTargetRPM = 70;
			vel_TBH_SetTargetVelocity(&launcherTBH, launcherTargetRPM, 57);

			waitForZero(vexRT[JOY_TRIG_RU]);
		}

		/* -------------- INTAKE -------------- */

		//Outside intake should turn inwards
		if (vexRT[JOY_TRIG_LU] == 1 || vexRT[JOY_TRIG_LD] == 1)
		{
			setOutsideIntakeMotors(127);
		}
		//Outside intake should turn outwards
		else if (vexRT[JOY_BTN_LU])
		{
			setOutsideIntakeMotors(-127);
		}
		//Intake should not turn
		else
		{
			setOutsideIntakeMotors(0);
		}

		//Inside intake should turn inwards
		if (vexRT[JOY_TRIG_LD])
		{
			//setInsideIntakeMotors(127);

			//If launcher is running
			if (launcherOn)
			{
				//If ball is ready
				if (SensorValue[intakeLimit] == 1)
				{
					//Place timeout mark
					timer_PlaceHardMarker(&intakeTimer);

					//If velocity controller has low error
					if (abs(vel_TBH_GetError(&launcherTBH)) < intakeMinimumError)
					{
						launcherBypass = true;

						//After exiting this block, the intake will have been running inwards so set the flag
						intake_prevStateIn = true;
						setInsideIntakeMotors(127);
						wait1Msec(70);

						if (SensorValue[intakeLimit] == 0)
						{
							launcherBypass = false;
						}
					}
					////If velocity controller does not have low error but intake timeout has expired
					//else if (intakeUseTimeout && timer_GetDTFromMarker(&intakeTimer) >= intakeTimeoutMs)
					//{
					//	//After exiting this block, the intake will have been running inwards so set the flag
					//	intake_prevStateIn = true;
					//	setInsideIntakeMotors(127);

					//	//Do not use the timeout after this
					//	intakeUseTimeout = false;

					//	//Light timeout LED
					//	SensorValue[intakeLED] = LED_ON;
					//}
					//Launcher not ready
					else
					{
						if (intake_prevStateIn)
						{
							//Send a backwards jolt to the intake
							setInsideIntakeMotors(-127);
							wait1Msec(40);
							setInsideIntakeMotors(127);
							wait1Msec(10);
							setInsideIntakeMotors(0);

							intake_prevStateIn = false;
						}
						else
						{
							setInsideIntakeMotors(0);
						}
					}
				}
				//If ball is not ready
				else
				{
					//After exiting this block, the intake will have been running inwards so set the flag
					intake_prevStateIn = true;
					setInsideIntakeMotors(127);
				}
			}
			//If launcher is not running
			else
			{
				//After exiting this block, the intake will have been running inwards so set the flag
				intake_prevStateIn = true;
				setInsideIntakeMotors(127);
			}
		}
		//Inside intake should turn outwards
		else if (vexRT[JOY_BTN_LD])
		{
			setInsideIntakeMotors(-127);
			timer_ClearHardMarker(&intakeTimer);
		}
		//Inside intake should not run
		else
		{
			//If the intake was previously turning inwards, stop it from drifting
			if (intake_prevStateIn)
			{
				//Send a backwards jolt to the intake
				setInsideIntakeMotors(-127);
				wait1Msec(40);
				setInsideIntakeMotors(127);
				wait1Msec(10);

				//Stop the intake
				setInsideIntakeMotors(0);

				//After exiting this block, the intake will not have been running
				intake_prevStateIn = false;
			}
			//If the intake was not previously turning inwards
			else
			{
				//Stop the intake
				setInsideIntakeMotors(0);
			}

			timer_ClearHardMarker(&intakeTimer);
		}

		/* ------------- LAUNCHER ------------- */

		//Launcher on flag
		if (vexRT[JOY_TRIG_RD])
		{
			launcherOn = !launcherOn;

			//Wait for the button to be released before continuing
			waitForZero(vexRT[JOY_TRIG_RD]);
		}

		//If the launcher should run
		if (launcherOn)
		{
			//Get into proper gear
			shiftGear(1);

			//Set the TBH controller's target velocity to the new target velocity
			//if the target velocity has changed
			if (launcherTargetRPM != launcherTargetRPM_last)
			{
				vel_TBH_SetTargetVelocity(&launcherTBH, launcherTargetRPM);
			}

			//Remember the current target rpm
			launcherTargetRPM_last = launcherTargetRPM;

			//Rev the launcher to 127 while far under target
			if (vel_TBH_GetVelocity(&launcherTBH) <= launcherTargetRPM - 10)
			{
				vel_TBH_StepVelocity(&launcherTBH);
				//vel_TBH_StepController(&launcherTBH);
				launcherCurrentPower = 127;
				launcherJustBoosted = true;
			}
			//Use a velocity controller when close to target
			else
			{
				//Step the TBH controller and get the output
				launcherCurrentPower = vel_TBH_StepController(&launcherTBH);

				//Bound the output to [0, inf) to prevent the launcher from running backwards
				launcherCurrentPower = launcherCurrentPower < 0 ? 0 : launcherCurrentPower;

				if (launcherJustBoosted)
				{
					launcherJustBoosted = false;
					launcher_UseBypass = true;
				}
			}

			//Rev the launcher right after firing a ball
			if (SensorValue[intakeLimit] == 0 && limitSwitchLast)
			{
				if (!launcher127Time)
				{
					timer_PlaceMarker(&launcherTimer);
				}

				launcher127Time = true;
			}

			//Remember limit switch
			limitSwitchLast = (SensorValue[intakeLimit] == 1);

			//Rev launcher
			if (timer_GetDTFromMarker(&launcherTimer) <= 300)
			{
				launcher127Time = false;

				//If target is high
				if (vel_TBH_GetOpenLoopApprox(&launcherTBH) >= 72)
				{
					launcherCurrentPower = 127;
				}
				//If target is low
				else
				{
					launcherCurrentPower = 100;
				}
			}

			//Set motors to low slew rate to minimize torque on launcher
			setAllLauncherMotorsSlewRate(0.8);

			//Bypass slew rate if launcher just came out of high error boost
			if (launcher_UseBypass)
			{
				launcher_UseBypass = false;
				setAllLauncherMotors_Bypass(-launcherCurrentPower);
			}
			//Otherwise, set motors like normal
			else
			{
				setAllLauncherMotors(-launcherCurrentPower);
			}
		}
		//If the launcher should not run
		else
		{
			//Step velocity calculation
			vel_TBH_StepVelocity(&launcherTBH);
		}

		//Launcher speed targets
		//Full field shot
		if (vexRT[JOY_BTN_RL])
		{
			launcherTargetRPM = launcher_FullCourt;
			vel_TBH_SetTargetVelocity(&launcherTBH, launcherTargetRPM, launcher_FullCourt_Approx);

			//Wait for the button to be released before continuing
			waitForZero(vexRT[JOY_BTN_RL]);
		}

		//Half field shot
		if (vexRT[JOY_BTN_RR])
		{
			launcherTargetRPM = launcher_MidCourt;
			vel_TBH_SetTargetVelocity(&launcherTBH, launcherTargetRPM, launcher_MidCourt_Approx);

			//Wait for the button to be released before continuing
			waitForZero(vexRT[JOY_BTN_RR]);
		}

		//Increment target velocity
		if (vexRT[JOY_BTN_RU])
		{
			launcherTargetRPM += launcherRPMIncrement;
			vel_TBH_SetTargetVelocity(&launcherTBH, launcherTargetRPM, vel_TBH_GetOpenLoopApprox(&launcherTBH) + 1);

			launcherPOWER++;

			//Wait for the button to be released before continuing
			waitForZero(vexRT[JOY_BTN_RU]);
		}

		//Decrement target velocity
		if (vexRT[JOY_BTN_RD])
		{
			launcherTargetRPM -= launcherRPMIncrement;
			vel_TBH_SetTargetVelocity(&launcherTBH, launcherTargetRPM, vel_TBH_GetOpenLoopApprox(&launcherTBH) - 1);

			launcherPOWER--;

			//Wait for the button to be released before continuing
			waitForZero(vexRT[JOY_BTN_RD]);
		}

		/* ------------- SHIFTER ------------- */

		//Invert the shifter's state
		//This is an unsafe shift
		if (vexRT[JOY_BTN_LR])
		{
			//Shift gear
			shiftGear();

			//Wait for the button to be released before continuing
			waitForZero(vexRT[JOY_BTN_LR]);
		}

		/* ------------- PARKING BRAKE ------------- */

		//Invert the brake's state
		if (vexRT[JOY_BTN_LL])
		{
			SensorValue[brake] = SensorValue[brake] == 1 ? 0 : 1;

			//Wait for the button to be released before continuing
			waitForZero(vexRT[JOY_BTN_LL]);
		}

		//Task sleep
		wait1Msec(25);
	}
}

//Run an autonomous function based on current selection
void startAutonomous()
{
	//Naming convention: <red side = 1, blue side = 2><left side = 1, right side = 2><primary = 1, secondary = 2, tertiary = 3>

	switch (autonSelection)
	{
		case 111:
			redLeftAutonPrimary();
			break;

		case 112:
			redLeftAutonSecondary();
			break;

		case 113:
			redLeftAutonTertiary();
			break;

		case 121:
			redRightAutonPrimary();
			break;

		case 122:
			redRightAutonSecondary();
			break;

		case 123:
			redRightAutonTertiary();
			break;

		case 211:
			blueLeftAutonPrimary();
			break;

		case 212:
			blueLeftAutonSecondary();
			break;

		case 213:
			blueLeftAutonTertiary();
			break;

		case 221:
			blueRightAutonPrimary();
			break;

		case 222:
			blueRightAutonSecondary();
			break;

		case 223:
			blueRightAutonTertiary();
			break;

		default:
			break;
	}
}

//LCD Library callback function
void invoke(int func)
{
	switch (func)
	{
		case 1:
			endPreAuton = true;
			stopTask(updateLCDTask);
			break;

		case 2:
			autonSelection = selectAutonomous();
			break;

		case 3:
			programmingSkills();
			break;

		default:
			break;
	}
}
