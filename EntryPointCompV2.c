#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    powerExpander,  sensorAnalog)
#pragma config(Sensor, in2,    gyro,           sensorGyro)
#pragma config(Sensor, in3,    accelX,         sensorAccelerometer)
#pragma config(Sensor, in4,    accelY,         sensorAccelerometer)
#pragma config(Sensor, in5,    leftLineSensor, sensorLineFollower)
#pragma config(Sensor, in6,    rightLineSensor, sensorLineFollower)
#pragma config(Sensor, dgtl1,  launcherQuad,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  brake,          sensorDigitalOut)
#pragma config(Sensor, dgtl4,  shifter,        sensorDigitalOut)
#pragma config(Sensor, dgtl5,  leftDriveQuad,  sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  rightDriveQuad, sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  intakeUltra,    sensorSONAR_mm)
#pragma config(Sensor, dgtl11, intakeLimit,    sensorTouch)
#pragma config(Sensor, I2C_1,  leftBankIME,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  rightBankIME,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           intakeFront,   tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           leftDriveBottomFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           leftDriveBottomBack, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port4,           leftDriveTopFront, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           leftDriveTopBack, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rightDriveBottomFront, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           rightDriveBottomBack, tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port8,           rightDriveTopFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           rightDriveTopBack, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          intakeBack,    tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

#pragma DebuggerWindows("Motors")
#pragma DebuggerWindows("Sensors")

#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

#include "Vex_Competition_Includes.c"

//Setup LCD
#define LCD_SAFETY_REQ_COMP_SWITCH
#define MENU_NUM 23
#define USING_QUADS
#define USING_GYRO

//Auton function prototypes
void startAutonomous();

//Whether or not to end pre auton
bool endPreAuton = false;

//The autonomous program to run
int autonSelection = -1;

#include "BCI_V3\Bulldog_Core_Includes.h"

//Launcher PID controller
vel_PID launcherPID;
vel_TBH launcherTBH;

//Autonomous program file includes
//#include "autonIncludes.h"
#include "Auton\redLeftAutonPrimary.c"
#include "Auton\redLeftAutonSecondary.c"
#include "Auton\redLeftAutonTertiary.c"

#include "Auton\redRightAutonPrimary.c"
#include "Auton\redRightAutonSecondary.c"
#include "Auton\redRightAutonTertiary.c"

#include "Auton\blueLeftAutonPrimary.c"
#include "Auton\blueLeftAutonSecondary.c"
#include "Auton\blueLeftAutonTertiary.c"

#include "Auton\blueRightAutonPrimary.c"
#include "Auton\blueRightAutonSecondary.c"
#include "Auton\blueRightAutonTertiary.c"

//Programming skills routine
#include "programmingSkills.c"

//Menus
//Level 1 - General Info
menu *autonomousSelectionMenu;
menu *endPreAutonMenu;
menu *batteryVoltageMenu;
menu *powerExpanderVoltageMenu;
menu *backupBatteryVoltageMenu;

void pre_auton()
{
	bStopTasksBetweenModes = true;

	//Initialize launcher PID controller
	vel_PID_InitController(&launcherPID, launcherQuad, 0.0035, 0, 0.03, 30, 50);
	vel_TBH_InitController(&launcherTBH, launcherQuad, 1, 90);

	//Iniialize all sensors
	initializeSensors();

	//Hand motors to slew rate controller
	addMotor(intakeFront, MOTOR_FAST_SLEW_RATE);
	addMotor(leftDriveBottomFront, MOTOR_FAST_SLEW_RATE);
	addMotor(leftDriveBottomBack, MOTOR_FAST_SLEW_RATE);
	addMotor(leftDriveTopFront, MOTOR_FAST_SLEW_RATE);
	addMotor(leftDriveTopBack, MOTOR_FAST_SLEW_RATE);
	addMotor(rightDriveBottomFront, MOTOR_FAST_SLEW_RATE);
	addMotor(rightDriveBottomBack, MOTOR_FAST_SLEW_RATE);
	addMotor(rightDriveTopFront, MOTOR_FAST_SLEW_RATE);
	addMotor(rightDriveTopBack, MOTOR_FAST_SLEW_RATE);
	addMotor(intakeBack, MOTOR_FAST_SLEW_RATE);

	//Menu system
	//Level 1 - General Info
	autonomousSelectionMenu = newMenu("Select Auton", 42);
	endPreAutonMenu = newMenu("Confirm", 1);

	string batteryVoltage;
	sprintf(batteryVoltage, "Main: %1.2f%c", nAvgBatteryLevel / 1000.0, 'V');
	batteryVoltageMenu = newMenu(batteryVoltage);

	string powerExpanderVoltage;
	sprintf(powerExpanderVoltage, "Expander: %1.2f%c", SensorValue[powerExpander] / 286.0, 'V');
	powerExpanderVoltageMenu = newMenu(powerExpanderVoltage);

	string backupBatteryVoltage;
	sprintf(backupBatteryVoltage, "Backup: %1.2f%c", BackupBatteryLevel / 1000.0, 'V');
	backupBatteryVoltageMenu = newMenu(backupBatteryVoltage);

	linkMenus(autonomousSelectionMenu, endPreAutonMenu, backupBatteryVoltageMenu, powerExpanderVoltageMenu, batteryVoltageMenu);

	bLCDBacklight = true;
	startTask(updateLCDTask);
	while (!getLCDSafetyState() && !endPreAuton) { wait1Msec(50); }

}

task autonomous()
{
	//autonSelection = 111;
	startAutonomous();
}

task usercontrol()
{
	//startTask(autonomous);
	//wait1Msec(15000);
	//stopTask(autonomous);

	//Drivetrain variables
	int leftV, rightV;

	//Intake variables
	const int intakeTimeoutMs = 2500;
	float intakeLastTime = 0;
	bool intake_prevStateIn = false;

	//Launcher variables
	bool launcherOn = false, stepController = true;
	int launcherTargetRPM = 0, launcherPOWER = 70, launcherPID_OUT = 0, launcherCurrentPower = 0;
	const int launcherRPMIncrement = 10;

	startTask(motorSlewRateTask);
	startTask(monitorRPM);

	bLCDBacklight = true;

	string line1String, line2String;

	while (true)
	{
		writeDebugStreamLine("%d", SensorValue[intakeUltra]);

		bLCDBacklight = true;

		//sprintf(line1String, "CV:%1.2f, T:%d", launcherTBH.currentVelocity, launcherTBH.targetVelocity);
		sprintf(line2String, "%d", launcherPOWER);
		sprintf(line1String, "L: %d, R: %d", getMotorVelocity(leftDriveBottomBack), getMotorVelocity(rightDriveBottomBack));
		displayLCDCenteredString(0, line1String);

		//sprintf(line2String, "%1.2f", SensorValue[powerExpander] / ANALOG_IN_TO_MV);
		//sprintf(line2String, "CP:%d", launcherCurrentPower);
		//sprintf(line2String, "LH: %d, RH: %d", getMotorVelocity(leftDriveBottomBack) * 25, getMotorVelocity(rightDriveBottomBack) * 25);
		displayLCDCenteredString(1, line2String);

		/* ------------ DRIVETRAIN ------------ */

		//If the launcher is not on
		if (!launcherOn)
		{
			//Change drive motors' slew rate back to normal after launcher control
			setAllDriveMotorsSlewRate(MOTOR_FAST_SLEW_RATE);

			//Grab values from joystick
			leftV = vexRT[JOY_JOY_LV];
			rightV = vexRT[JOY_JOY_RV];

			//Bound joystick values
			leftV = abs(leftV) < JOY_THRESHOLD ? 0 : leftV;
			rightV = abs(rightV) < JOY_THRESHOLD ? 0 : rightV;

			//Send these values to the drivetrain
			setLeftDriveMotors(leftV);
			setRightDriveMotors(rightV);
		}

		/* -------------- INTAKE -------------- */

		//Outside intake should turn inwards
		if (vexRT[JOY_TRIG_LD])
		{
			setOutsideIntakeMotors(127);
		}
		//Outside intake should turn outwards
		else if (vexRT[JOY_BTN_LU])
		{
			setOutsideIntakeMotors(-127);
		}
		//Outisde intake should not run
		else
		{
			setOutsideIntakeMotors(0);
		}

		//Inside intake should turn inwards
		if (vexRT[JOY_TRIG_LU])
		{
			//After exiting this conditional, the intake will have been running inwards so set the flag
			intake_prevStateIn = true;
			setInsideIntakeMotors(127);
		}
		//Inside intake should turn outwards
		else if (vexRT[JOY_BTN_LD])
		{
			setInsideIntakeMotors(-127);
		}
		//Inside intake should not run
		else
		{
			//If the intake was previously turning intwards, stop it from drifting
			if (intake_prevStateIn)
			{
				//Send a backwards jolt to the intake
				setInsideIntakeMotors(-127);
				wait1Msec(40);
				setInsideIntakeMotors(127);
				wait1Msec(10);

				//Stop the intake
				setInsideIntakeMotors(0);

				//After exiting this conditional, the intake will not have been running
				intake_prevStateIn = false;
			}
			//If the intake was not previously turning inwards
			else
			{
				//Stop the intake
				setInsideIntakeMotors(0);
			}
		}

		/* ------------- LAUNCHER ------------- */

		//Launcher on flag
		if (vexRT[JOY_TRIG_RD])
		{
			launcherOn = !launcherOn;

			//Wait for the button to be released before continuing
			waitForZero(vexRT[JOY_TRIG_RD]);
		}

		//PID math flag
		if (vexRT[JOY_TRIG_RU])
		{
			stepController = !stepController;

			//Wait for the button to be released before continuing
			waitForZero(vexRT[JOY_TRIG_RU]);
		}

		//If the launcher should run
		if (launcherOn)
		{
			//Synchronize motor bays
			//startTask(maintainMotorBaySpeed);

			//If the PID controller should step its calculations
			if (stepController)
			{
				/*
				//Set the PID controller's target velocity to the new target velocity
				launcherPID.targetVelocity = launcherTargetRPM;

				//Get the PID controller's output
				//launcherPID_OUT = vel_PID_StepController_VEL(&launcherPID);
				//launcherPID_OUT = vel_PID_StepController_ACCEL(&launcherPID);
				launcherPID_OUT = vel_TBH_StepController_VEL(&launcherTBH);

				//Bound the PID controller's output to [0, inf) so the launcher's motors can't reverse
				launcherPID_OUT = launcherPID_OUT < 0 ? 0 : launcherPID_OUT;
				*/

				//Set the TBH controller's target velocity to the new target velocity
				vel_TBH_SetTargetVelocity(&launcherTBH, launcherTargetRPM);

				//Step the TBH controller and get the output
				launcherCurrentPower = vel_TBH_StepController_VEL(&launcherTBH);

				//Bound the TBH controller's output to (-inf, 0] so the launcher's motors always run in the correct direction
				launcherCurrentPower = launcherCurrentPower < 0 ? 0 : launcherCurrentPower;
			}

			//Set motors to low slew rate to minimize torque on launcher
			setAllDriveMotorsSlewRate(0.7);
			iBaySpeedMaintainRate = -launcherCurrentPower;
			setAllDriveMotors(-launcherPOWER);
		}
		//If the launcher should not run
		else
		{
			//stopTask(maintainMotorBaySpeed);

			//Keep setting the PID controller's current velocity without stepping itself
			launcherPID.currentVelocity = 0.0;

			//Reset the output
			launcherPID.outVal = 0.0;
		}

		//Launcher speed targets
		//Full field shot
		if (vexRT[JOY_BTN_RL])
		{
			launcherTargetRPM = 40;
			launcherPOWER = 60;

			//Wait for the button to be released before continuing
			waitForZero(vexRT[JOY_BTN_RL]);
		}

		//Half field shot
		if (vexRT[JOY_BTN_RR])
		{
			launcherTargetRPM = 60;
			launcherPOWER = 50;

			//Wait for the button to be released before continuing
			waitForZero(vexRT[JOY_BTN_RR]);
		}

		//Increment target velocity
		if (vexRT[JOY_BTN_RU])
		{
			launcherTargetRPM += launcherRPMIncrement;
			launcherPOWER++;

			//Wait for the button to be released before continuing
			waitForZero(vexRT[JOY_BTN_RU]);
		}

		//Decrement target velocity
		if (vexRT[JOY_BTN_RD])
		{
			launcherTargetRPM -= launcherRPMIncrement;
			launcherPOWER--;

			//Wait for the button to be released before continuing
			waitForZero(vexRT[JOY_BTN_RD]);
		}

		/* ------------- SHIFTER ------------- */

		//Invert the shifter's state
		if (vexRT[JOY_BTN_LR])
		{
			//Do not allow a shift while the launcher is running
			//The robot risks signifigant damage
			if (launcherOn)
			{
				launcherOn = false;

				//Semi e-stop motors
				setAllDriveMotorsRaw(0);
			}

			//Shift gear
			shiftGear();

			//Wait for the button to be released before continuing
			waitForZero(vexRT[JOY_BTN_LR]);
		}

		/* ------------- PARKING BRAKE ------------- */

		//Invert the brake's state
		if (vexRT[JOY_BTN_LL])
		{
			SensorValue[brake] = SensorValue[brake] == 1 ? 0 : 1;

			//Wait for the button to be released before continuing
			waitForZero(vexRT[JOY_BTN_LL]);
		}

		//Task sleep
		wait1Msec(25);
	}
}

void startAutonomous()
{
	//Naming convention: <red side = 1, blue side = 2><left side = 1, right side = 2><primary = 1, secondary = 2, tertiary = 3>

	switch (autonSelection)
	{
		case 111:
			redLeftAutonPrimary();
			break;

		case 112:
			redLeftAutonSecondary();
			break;

		case 113:
			redLeftAutonTertiary();
			break;

		case 121:
			redRightAutonPrimary();
			break;

		case 122:
			redRightAutonSecondary();
			break;

		case 123:
			redRightAutonTertiary();
			break;

		case 211:
			blueLeftAutonPrimary();
			break;

		case 212:
			blueLeftAutonSecondary();
			break;

		case 213:
			blueLeftAutonTertiary();
			break;

		case 221:
			blueRightAutonPrimary();
			break;

		case 222:
			blueRightAutonSecondary();
			break;

		case 223:
			blueRightAutonTertiary();
			break;

		default:
			break;
	}
}

void invoke(int func)
{
	if (func == 1)
	{
		endPreAuton = true;
		stopTask(updateLCDTask);
	}
	else if (func == 42)
	{
		autonSelection = selectAutonomous();
	}
}
