#pragma config(Sensor, in1,    powerExpander,  sensorAnalog)
#pragma config(Sensor, in2,    gyro,           sensorGyro)
#pragma config(Sensor, in3,    accelX,         sensorAccelerometer)
#pragma config(Sensor, in4,    accelY,         sensorAccelerometer)
#pragma config(Sensor, in5,    leftLineSensor, sensorLineFollower)
#pragma config(Sensor, in6,    rightLineSensor, sensorLineFollower)
#pragma config(Sensor, dgtl1,  launcherQuad,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  brake,          sensorDigitalOut)
#pragma config(Sensor, dgtl4,  shifter,        sensorDigitalOut)
#pragma config(Sensor, dgtl5,  leftDriveQuad,  sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  rightDriveQuad, sensorQuadEncoder)
#pragma config(Sensor, dgtl11, intakeLimit,    sensorTouch)
#pragma config(Sensor, dgtl12, pidMathLight,   sensorDigitalOut)
#pragma config(Motor,  port1,           intakeFront,   tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           leftDriveBottomFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           leftDriveBottomBack, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           leftDriveTopFront, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           leftDriveTopBack, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rightDriveBottomFront, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           rightDriveBottomBack, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rightDriveTopFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           rightDriveTopBack, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          intakeBack,    tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

#pragma DebuggerWindows("Motors")
#pragma DebuggerWindows("Sensors")

#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

#include "Vex_Competition_Includes.c"

#define LCD_SAFETY_REQ_COMP_SWITCH
#define MENU_NUM 23
#define USING_QUADS
#define USING_GYRO

//Auton function prototypes
void startAutonomous();

//Whether or not to end pre auton
bool endPreAuton = false;

//The autonomous program to run
int autonSelection = -1;

#include "VelocityPID.c"
vel_PID launcherPID;

#include "BCI_V3\Bulldog_Core_Includes.h"

//Autonomous program file includes
//#include "autonIncludes.h"
#include "Auton\redLeftAutonPrimary.c"
#include "Auton\redLeftAutonSecondary.c"
#include "Auton\redLeftAutonTertiary.c"

#include "Auton\redRightAutonPrimary.c"
#include "Auton\redRightAutonSecondary.c"
#include "Auton\redRightAutonTertiary.c"

#include "Auton\blueLeftAutonPrimary.c"
#include "Auton\blueLeftAutonSecondary.c"
#include "Auton\blueLeftAutonTertiary.c"

#include "Auton\blueRightAutonPrimary.c"
#include "Auton\blueRightAutonSecondary.c"
#include "Auton\blueRightAutonTertiary.c"

//Programming skills routine
#include "programmingSkills.c"

//Menus
//Level 1 - General Info
menu *autonomousSelectionMenu;
menu *endPreAutonMenu;
menu *batteryVoltageMenu;
menu *powerExpanderVoltageMenu;
menu *backupBatteryVoltageMenu;

//Level 2 - Color Selection
menu *redSideMenu;
menu *blueSideMenu;

//Level 3 - Tile Selection - Red
menu *redLeftTileMenu;
menu *redRightTileMenu;

//Level 3 - Tile Selection - Blue
menu *blueLeftTileMenu;
menu *blueRightTileMenu;

//Level 4 - Autonomous Selection - Red Left
menu *redLeftAutonPrimaryMenu;
menu *redLeftAutonSecondaryMenu;
menu *redLeftAutonTertiaryMenu;

//Level 4 - Autonomous Selection - Red Right
menu *redRightAutonPrimaryMenu;
menu *redRightAutonSecondaryMenu;
menu *redRightAutonTertiaryMenu;

//Level 4 - Autonomous Selection - Blue Left
menu *blueLeftAutonPrimaryMenu;
menu *blueLeftAutonSecondaryMenu;
menu *blueLeftAutonTertiaryMenu;

//Level 4 - Autonomous Selection - Blue Right
menu *blueRightAutonPrimaryMenu;
menu *blueRightAutonSecondaryMenu;
menu *blueRightAutonTertiaryMenu;

void pre_auton()
{
	bStopTasksBetweenModes = true;

	//Initialize launcher PID controller
	vel_PID_InitController(&launcherPID, launcherQuad, 0.0035, 0, 0.03, 30, 50);

	//Iniialize all sensors
	initializeSensors();

	//Hand motors to slew rate controller
	addMotor(intakeFront, MOTOR_FAST_SLEW_RATE);
	addMotor(leftDriveBottomFront, MOTOR_FAST_SLEW_RATE);
	addMotor(leftDriveBottomBack, MOTOR_FAST_SLEW_RATE);
	addMotor(leftDriveTopFront, MOTOR_FAST_SLEW_RATE);
	addMotor(leftDriveTopBack, MOTOR_FAST_SLEW_RATE);
	addMotor(rightDriveBottomFront, MOTOR_FAST_SLEW_RATE);
	addMotor(rightDriveBottomBack, MOTOR_FAST_SLEW_RATE);
	addMotor(rightDriveTopFront, MOTOR_FAST_SLEW_RATE);
	addMotor(rightDriveTopBack, MOTOR_FAST_SLEW_RATE);
	addMotor(intakeBack, MOTOR_FAST_SLEW_RATE);

	//Menu system
	//Level 1 - General Info
	autonomousSelectionMenu = newMenu("Auton Menus");
	endPreAutonMenu = newMenu("Confirm", 1);

	string batteryVoltage;
	sprintf(batteryVoltage, "Main: %1.2f%c", nAvgBatteryLevel / 1000.0, 'V');
	batteryVoltageMenu = newMenu(batteryVoltage);

	string powerExpanderVoltage;
	sprintf(powerExpanderVoltage, "Expander: %1.2f%c", SensorValue[powerExpander] / 286.0, 'V');
	powerExpanderVoltageMenu = newMenu(powerExpanderVoltage);

	string backupBatteryVoltage;
	sprintf(backupBatteryVoltage, "Backup: %1.2f%c", BackupBatteryLevel / 1000.0, 'V');
	backupBatteryVoltageMenu = newMenu(backupBatteryVoltage);

	linkMenus(autonomousSelectionMenu, endPreAutonMenu, backupBatteryVoltageMenu, powerExpanderVoltageMenu, batteryVoltageMenu);

	//Level 2 - Color Selection
	redSideMenu = newMenu("Red Side");
	blueSideMenu = newMenu("Blue Side");

	linkMenus(redSideMenu, blueSideMenu);

	//Level 3 - Tile Selection - Red
	redLeftTileMenu = newMenu("Left Tile");
	redRightTileMenu = newMenu("Right Tile");

	linkMenus(redLeftTileMenu, redRightTileMenu);


	//Level 3 - Tile Selection - Blue
	blueLeftTileMenu = newMenu("Left Tile");
	blueRightTileMenu = newMenu("Right Tile");

	linkMenus(blueLeftTileMenu, blueRightTileMenu);

	//Level 4 - Autonomous Selection - Red Left
	redLeftAutonPrimaryMenu = newMenu("Primary Auton", 111);
	redLeftAutonSecondaryMenu = newMenu("Secondary Auton", 112);
	redLeftAutonTertiaryMenu = newMenu("Tertiary Auton", 113);

	linkMenus(redLeftAutonPrimaryMenu, redLeftAutonSecondaryMenu, redLeftAutonTertiaryMenu);

	//Level 4 - Autonomous Selection - Red Right
	redRightAutonPrimaryMenu = newMenu("Primary Auton", 121);
	redRightAutonSecondaryMenu = newMenu("Secondary Auton", 122);
	redRightAutonTertiaryMenu = newMenu("Tertiary Auton", 123);

	linkMenus(redRightAutonPrimaryMenu, redRightAutonSecondaryMenu, redRightAutonTertiaryMenu);

	//Level 4 - Autonomous Selection - Blue Left
	blueLeftAutonPrimaryMenu = newMenu("Primary Auton", 211);
	blueLeftAutonSecondaryMenu = newMenu("Secondary Auton", 212);
	blueLeftAutonTertiaryMenu = newMenu("Tertiary Auton", 213);

	linkMenus(blueLeftAutonPrimaryMenu, blueLeftAutonSecondaryMenu, blueLeftAutonTertiaryMenu);

	//Level 4 - Autonomous Selection - Blue Right
	blueRightAutonPrimaryMenu = newMenu("Primary Auton", 221);
	blueRightAutonSecondaryMenu = newMenu("Secondary Auton", 222);
	blueRightAutonTertiaryMenu = newMenu("Tertiary Auton", 223);

	linkMenus(blueRightAutonPrimaryMenu, blueRightAutonSecondaryMenu, blueRightAutonTertiaryMenu);

	//formLevel can only be called after all menus have been initialized
	//Calling formLevel before initializing all menus can result in a null pointer error and system hardlock
	formLevel(autonomousSelectionMenu, redSideMenu, blueSideMenu);

	formLevel(redSideMenu, redLeftTileMenu, redRightTileMenu);
	formLevel(blueSideMenu, blueLeftTileMenu, blueRightTileMenu);

	formLevel(redLeftTileMenu, redLeftAutonPrimaryMenu, redLeftAutonSecondaryMenu, redLeftAutonTertiaryMenu);
	formLevel(redRightTileMenu, redRightAutonPrimaryMenu, redRightAutonSecondaryMenu, redRightAutonTertiaryMenu);

	formLevel(blueLeftTileMenu, blueLeftAutonPrimaryMenu, blueLeftAutonSecondaryMenu, blueLeftAutonTertiaryMenu);
	formLevel(blueRightTileMenu, blueRightAutonPrimaryMenu, blueRightAutonSecondaryMenu, blueRightAutonTertiaryMenu);

	bLCDBacklight = true;
	startTask(updateLCDTask);
	while (!getLCDSafetyState() && !endPreAuton) { wait1Msec(50); }

}

task autonomous()
{
	//autonSelection = 111;
	startAutonomous();
}

task usercontrol()
{
	//startTask(autonomous);
	//wait1Msec(15000);
	//stopTask(autonomous);

	//Drivetrain variables
	int leftV, rightV;

	//Intake variables
	const int intakeTimeoutMs = 2500;
	float intakeLastTime = 0;
	bool intake_prevStateIn = false;

	//Launcher variables
	bool launcherOn = false, stepController = true;
	int launcherTargetRPM = 0, launcherPOWER = 70, launcherPID_OUT = 0;
	const int launcherRPMIncrement = 10;

	//Transmission variables
	bool shifterEngaged_Manual = false;

	startTask(motorSlewRateTask);
	startTask(monitorRPM);

	bLCDBacklight = true;

	string rpmString, fullRpmString, targetRpmString;

	while (true)
	{
		bLCDBacklight = true;

		//sprintf(fullRpmString, "%1.2f", launcherPID.currentVelocity);
		sprintf(fullRpmString, "%d", launcherPOWER);
		displayLCDCenteredString(0, fullRpmString);

		sprintf(targetRpmString, "%1.2f", SensorValue[powerExpander] / 286.0);
		displayLCDCenteredString(1, targetRpmString);

		/* ------------ DRIVETRAIN ------------ */

		//If the launcher is not on
		if (!launcherOn)
		{
			//Grab values from joystick
			leftV = vexRT[JOY_JOY_LV];
			rightV = vexRT[JOY_JOY_RV];

			//Bound joystick values
			leftV = abs(leftV) < JOY_THRESHOLD ? 0 : leftV;
			rightV = abs(rightV) < JOY_THRESHOLD ? 0 : rightV;

			//Send these values to the drivetrain
			setLeftDriveMotors(leftV);
			setRightDriveMotors(rightV);
		}

		/* -------------- INTAKE -------------- */

		//If the intake should turn inwards
		if (vexRT[JOY_TRIG_LD])
		{
			//After exiting this conditional, the intake will have been running inwards
			intake_prevStateIn = true;

			/*
			//If a ball is waiting to launch
			if (SensorValue[intakeLimit])
			{
				//First time the limit has been hit since a launch
				if (intakeLastTime == 0)
				{
					intakeLastTime = time1[T1];
				}
				//If the timeout has expired
				else if (time1[T1] - intakeLastTime >= intakeTimeoutMs)
				{
					setIntakeMotors(127);
				}

				//If the launcher is at the correct speed
				if (leftRPM >= launcherTargetRPM - 20 || rightRPM >= launcherTargetRPM - 20)
				{
					setIntakeMotors(127);
				}
				else
				{
					setIntakeMotors(0);
				}
			}
			//Ball is not waiting to launch
			else
			{
				setIntakeMotors(127);
			}
			*/
			setIntakeMotors(127);
		}
		//If the intake should turn outwards
		else if (vexRT[JOY_TRIG_LU])
		{
			//Reverse the intake
			setIntakeMotors(-127);
		}
		//If the intake should not run
		else
		{
			//If the intake was previously turning intwards, stop it from drifting
			if (intake_prevStateIn)
			{
				//Send a backwards jolt to the intake
				setIntakeMotors(-127);
				wait1Msec(40);
				setIntakeMotors(127);
				wait1Msec(10);

				//Stop the intake
				setIntakeMotors(0);

				//After exiting this conditional, the intake will not have been running
				intake_prevStateIn = false;
			}
			//If the intake was not previously turning inwards
			else
			{
				//Stop the intake
				setIntakeMotors(0);
			}
		}

		/* ------------- LAUNCHER ------------- */

		//Launcher on flag
		if (vexRT[JOY_TRIG_RD])
		{
			launcherOn = !launcherOn;

			//Wait for the button to be released before continuing
			waitForZero(vexRT[JOY_TRIG_RD]);
		}

		//PID math flag
		if (vexRT[JOY_TRIG_RU])
		{
			stepController = !stepController;

			//Wait for the button to be released before continuing
			waitForZero(vexRT[JOY_TRIG_RU]);
		}

		//If the launcher should run
		if (launcherOn)
		{
			//If the PID controller should step its calculations
			if (stepController)
			{
				//Turn on an LED to show the driver the PID controller is stepping its calculations
				SensorValue[pidMathLight] = LED_ON;

				//Set the PID controller's target velocity to the new target velocity
				launcherPID.targetVelocity = launcherTargetRPM;

				//Get the PID controller's output
				//launcherPID_OUT = vel_PID_StepController_VEL(&launcherPID);
				launcherPID_OUT = vel_PID_StepController_ACCEL(&launcherPID);

				//Bound the PID controller's output to [0, 127] so the launcher's motors can't reverse
				launcherPID_OUT = launcherPID_OUT < 0 ? 0 : launcherPID_OUT;
			}
			//If the PID controller should not step its calculations
			else
			{
				//Turn off an LED to show the driver the PID controller is not stepping its calculations
				SensorValue[pidMathLight] = LED_OFF;
			}

			//Handle shifter state
			shifterEngaged_Manual = false;
			SensorValue[shifter] = 1;
			
			/*if (launcherPID_OUT > 0)
			{
				setAllDriveMotors(127);
			}
			else if (launcherPID_OUT < 0)
			{
				setAllDriveMotors(-127);
			}

			setMotorSlew(leftDriveBottomFront, launcherPID_OUT);
			setMotorSlew(leftDriveBottomBack, launcherPID_OUT);
			setMotorSlew(leftDriveTopFront, launcherPID_OUT);
			setMotorSlew(leftDriveTopBack, launcherPID_OUT);
			setMotorSlew(rightDriveBottomFront, launcherPID_OUT);
			setMotorSlew(rightDriveBottomBack, launcherPID_OUT);
			setMotorSlew(rightDriveTopFront, launcherPID_OUT);
			setMotorSlew(rightDriveTopBack, launcherPID_OUT);*/

			setAllDriveMotors(launcherPOWER);
		}
		//If the launcher should not run
		else
		{
			//Keep setting the PID controller's current velocity without stepping itself
			launcherPID.currentVelocity = 0.0;

			//Reset the output
			launcherPID.outVal = 0.0;

			//If shifter was manually engaged, ignore automatic setting
			if (!shifterEngaged_Manual)
			{
				SensorValue[shifter] = 0;
			}
		}

		//Launcher speed targets
		//Full field shot
		if (vexRT[JOY_BTN_RL])
		{
			launcherTargetRPM = 203;
			launcherPOWER = 70;

			//Wait for the button to be released before continuing
			waitForZero(vexRT[JOY_BTN_RL]);
		}

		//Half field shot
		if (vexRT[JOY_BTN_RR])
		{
			launcherTargetRPM = 140;
			launcherPOWER = 60;

			//Wait for the button to be released before continuing
			waitForZero(vexRT[JOY_BTN_RR]);
		}

		//Increment target velocity
		if (vexRT[JOY_BTN_RU])
		{
			launcherTargetRPM += launcherRPMIncrement;
			launcherPOWER++;

			//Wait for the button to be released before continuing
			waitForZero(vexRT[JOY_BTN_RU]);
		}

		//Decrement target velocity
		if (vexRT[JOY_BTN_RD])
		{
			launcherTargetRPM -= launcherRPMIncrement;
			launcherPOWER--;

			//Wait for the button to be released before continuing
			waitForZero(vexRT[JOY_BTN_RD]);
		}

		/* ------------- SHIFTER ------------- */

		//Invert the shifter's state
		if (vexRT[JOY_BTN_LR])
		{
			SensorValue[shifter] = SensorValue[shifter] == 1 ? 0 : 1;
			shifterEngaged_Manual = true;

			//Wait for the button to be released before continuing
			waitForZero(vexRT[JOY_BTN_LR]);
		}

		/* ------------- PARKING BRAKE ------------- */

		//Invert the brake's state
		if (vexRT[JOY_BTN_LL])
		{
			SensorValue[brake] = SensorValue[brake] == 1 ? 0 : 1;

			//Wait for the button to be released before continuing
			waitForZero(vexRT[JOY_BTN_LL]);
		}

		//Task sleep
		wait1Msec(25);
	}
}

void startAutonomous()
{
	//Naming convention: <red side = 1, blue side = 2><left side = 1, right side = 2><primary = 1, secondary = 2, tertiary = 3>

	switch (autonSelection)
	{
		case 111:
			redLeftAutonPrimary();
			break;

		case 112:
			redLeftAutonSecondary();
			break;

		case 113:
			redLeftAutonTertiary();
			break;

		case 121:
			redRightAutonPrimary();
			break;

		case 122:
			redRightAutonSecondary();
			break;

		case 123:
			redRightAutonTertiary();
			break;

		case 211:
			blueLeftAutonPrimary();
			break;

		case 212:
			blueLeftAutonSecondary();
			break;

		case 213:
			blueLeftAutonTertiary();
			break;

		case 221:
			blueRightAutonPrimary();
			break;

		case 222:
			blueRightAutonSecondary();
			break;

		case 223:
			blueRightAutonTertiary();
			break;

		default:
			break;
	}
}

void invoke(int func)
{
	if (func == 1)
	{
		endPreAuton = true;
		stopTask(updateLCDTask);
	}
	else
	{
		autonSelection = func;
	}
}
